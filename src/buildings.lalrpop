use crate::building::{AtmosphereImpact,BuildingData,CustomGood,MagnetosphereImpact,Station,StationField,Field,BuildingToken};

use rust_decimal::prelude::*;

grammar;

extern {
    type Location = usize;
    type Error = String;

    enum BuildingToken {
        "true" => BuildingToken::True,
        "false" => BuildingToken::False,
        "=" => BuildingToken::Equal,

        "{" => BuildingToken::LeftCurly,
        "}" => BuildingToken::RightCurly,
        "[" => BuildingToken::LeftSquare,
        "]" => BuildingToken::RightSquare,
        
        "string" => BuildingToken::String(<String>),
        "number" => BuildingToken::DecimalNumber(<Decimal>),
        "negative_number" => BuildingToken::NegativeNumber(<Decimal>),

        "id" => BuildingToken::Id,
        "name" => BuildingToken::Name,
        "planet_filters" => BuildingToken::PlanetFilters,
        "initial" => BuildingToken::Initial,
        "unique" => BuildingToken::Unique,
        "energy" => BuildingToken::Energy,

        "private_costs" => BuildingToken::PrivateCosts,
        "costs" => BuildingToken::Costs,
        "consumes" => BuildingToken::Consumes,
        "upkeep" => BuildingToken::Upkeep,
        "produces" => BuildingToken::Produces,

        "housing" => BuildingToken::Housing,
        "workers" => BuildingToken::Workers,

        "stations" => BuildingToken::Stations,
        
        "private_sector" => BuildingToken::PrivateSector,
        "magnetosphere_equilibrium" => BuildingToken::MagnetosphereEquilibrium,
        "atmosphere_equilibrium" => BuildingToken::AtmosphereEquilibrium,
        "temperature_change" => BuildingToken::TemperatureChange,
        "water_change" => BuildingToken::WaterChange,
        "breathable_change" => BuildingToken::BreathableChange,
        "tech_needed" => BuildingToken::TechNeeded,
        "upgrades_from" => BuildingToken::UpgradesFrom,
        "prosperity_per_job" => BuildingToken::ProsperityPerJob,

        "rate" => BuildingToken::Rate,
        "added" => BuildingToken::Added,

        "x" => BuildingToken::X,
        "y" => BuildingToken::Y,
        "z" => BuildingToken::Z,
        "scale" => BuildingToken::Scale,
        "path" => BuildingToken::Path,
    }
}

pub Buildings:Vec<BuildingData> = {
    Building*
}

Building:BuildingData = {
    <id:"string"> <fields:Field*> => {
        let mut building_data = BuildingData::default();
        building_data.id = id;
        for f in fields {
            match f {
                Field::Name(n) => {
                    building_data.name = n;
                }
                Field::PlanetFilters(p) => {
                    building_data.planet_filters = p;
                }
                Field::Initial(i) => {
                    building_data.initial = i;
                }
                Field::Unique(u) => {
                    building_data.unique = u;
                }
                Field::Energy(d) => {
                    building_data.energy = d;
                }
                Field::PrivateCosts(d) => {
                    building_data.private_costs = d;
                }
                Field::Costs(c) => building_data.costs = c,
                Field::Consumes(c) => building_data.consumes = c,
                Field::Upkeep(u) => building_data.upkeep = u,
                Field::Produces(p) => building_data.produces = p,
                Field::Housing(h) => building_data.housing = h,
                Field::Workers(w) => building_data.workers = w,
                Field::PrivateSector(p) => {
                    building_data.private_sector = p;
                }
                Field::Magnetosphere(m) => {
                    building_data.magnetosphere_equilibrium = m;
                }
                Field::Atmosphere(a) => {
                    building_data.atmosphere_equilibrium = a;
                }
                Field::TemperatureChange(t) => {
                    building_data.temperature_change = t;
                }
                Field::WaterChange(w) => {
                    building_data.water_change = w;
                }
                Field::BreathableChange(b) => {
                    building_data.breathable_change = b;
                }
                Field::TechNeeded(t) => {
                    building_data.tech_needed = Some(t);
                }
                Field::UpgradesFrom(t) => {
                    building_data.upgrades_from = Some(t);
                }
                Field::ProsperityPerJob(p) => {
                    building_data.prosperity_per_job = p;
                }
                Field::Stations(s) => {
                    building_data.stations = s;
                }
            }
        }
        building_data
    }
}

Field:Field = {
    <n:Name> => Field::Name(n),
    <p:PlanetFilters> => Field::PlanetFilters(p),
    <i:Initial> => Field::Initial(i),
    <u:Unique> => Field::Unique(u),
    <e:Energy> => Field::Energy(e),
    <p:PrivateCosts> => Field::PrivateCosts(p),
    <c:Costs> => Field::Costs(c),
    <c:Consumes> => Field::Consumes(c),
    <u:Upkeep> => Field::Upkeep(u),
    <p:Produces> => Field::Produces(p),
    <h:Housing> => Field::Housing(h),
    <w:Workers> => Field::Workers(w),
    <p:PrivateSector> => Field::PrivateSector(p),
    <m:MagnetosphereEquilibrium> => Field::Magnetosphere(m),
    <a:AtmosphereEquilibrium> => Field::Atmosphere(a),
    <t:TemperatureChange> => Field::TemperatureChange(t),
    <w:WaterChange> => Field::WaterChange(w),
    <b:BreathableChange> => Field::BreathableChange(b),
    <t:TechNeeded> => Field::TechNeeded(t),
    <u:UpgradesFrom> => Field::UpgradesFrom(u),
    <p:ProsperityPerJob> => Field::ProsperityPerJob(p),
    <s:Stations> => Field::Stations(s),
}

Costs:Vec<CustomGood> = {
    "costs" "=" "[" <c:CustomGood+> "]" => c,
}

Consumes:Vec<CustomGood> = {
    "consumes" "=" "[" <c:CustomGood+> "]" => c,
}

Produces:Vec<CustomGood> = {
    "produces" "=" "[" <c:CustomGood+> "]" =>c,
}

Upkeep:Vec<CustomGood> = {
    "upkeep" "=" "[" <c:CustomGood+> "]" => c,
}

CustomGood:CustomGood = {
    "{" <id:"string"> <amount:"number"> "}" => {
        CustomGood{
            id,
            amount,
        }
    }
}

Id:String = {
    "id" "=" <id:"string"> => id,
}

Name:String = {
    "name" "=" <id:"string"> => id,
}

PlanetFilters:Vec<String> = {
    "planet_filters" "=" "[" <planets:"string"+> "]" => planets,
}

Initial:bool = {
    "initial" "=" <b:Bool> => b,
}

Unique:bool = {
    "unique" "=" <b:Bool> => b,
}

Energy:Decimal = {
    "energy" "=" <n:RealNumber> => n,
}

Housing:u64 = {
    "housing" "=" <n:"number"> => n.try_into().unwrap(),
}

Workers:u64 = {
    "workers" "=" <n:"number"> => n.try_into().unwrap(),
}

PrivateCosts:Decimal = {
    "private_costs" "=" <n:"number"> => n,
}

MagnetosphereEquilibrium:MagnetosphereImpact = {
    "magnetosphere_equilibrium" "=" "{" "added" "=" <n:"number"> "rate" "=" <r:"number"> "}" => {
        MagnetosphereImpact {
            added_equilibrium:n,
            rate:r,
        }
    },
}

AtmosphereEquilibrium:AtmosphereImpact = {
    "atmosphere_equilibrium" "=" "{" "added" "=" <n:"number"> "rate" "=" <r:"number"> "}" => {
        AtmosphereImpact {
            added_equilibrium:n,
            rate:r,
        }
     },
}

TemperatureChange:Decimal = {
    "temperature_change" "=" <n:"number"> => n,
}

WaterChange:Decimal = {
    "water_change" "=" <n:"number"> => n,
}

BreathableChange:Decimal = {
    "breathable_change" "=" <n:"number"> => n,
}

TechNeeded:String = {
    "tech_needed" "=" <s:"string"> => s,
}

UpgradesFrom:String = {
    "upgrades_from" "=" <s:"string"> => s,
}

PrivateSector:bool = {
    "private_sector" "=" <b:Bool> => b,
}

ProsperityPerJob:Decimal = {
    "prosperity_per_job" "=" <n:"number"> => n,
}

Stations:Vec<Station> = {
    "stations" "=" "[" <g:Station*> "]" => g,
}

Station:Station ={
     "{" <fields:StationField*> "}" => {
        let mut station = Station::default();
        for f in fields{
            match f {
                StationField::X(x) => {
                    station.x = x;
                }
                StationField::Y(y) => {
                    station.y = y;
                }
                StationField::Z(z) => {
                    station.z = z;
                }
                StationField::Scale(s) => {
                    station.scale = s;
                }
                StationField::Path(p) => {
                    station.path = p;
                }
            }
        }
        station
    }
}

StationField:StationField = {
    <x:X> => StationField::X(x),
    <y:Y> => StationField::Y(y),
    <z:Z> => StationField::Z(z),
    <s:Scale> => StationField::Scale(s),
    <p:Path> => StationField::Path(p),
}

X:f32 = {
    "x" "=" <n:RealNumber> => n.to_f32().unwrap(),
}

Y:f32 = {
    "y" "=" <n:RealNumber> => n.to_f32().unwrap(),
}

Z:f32 = {
    "z" "=" <n:RealNumber> => n.to_f32().unwrap(),
}

Scale:f32 = {
    "scale" "=" <n:"number"> => n.to_f32().unwrap(),
}

Path:String ={
    "path" "=" <s:"string"> => s,
}

RealNumber:Decimal = {
    <n:"number"> => n,
    <n:"negative_number"> => n,
}

Bool:bool = {
    "true" => true,
    "false" => false,
}
