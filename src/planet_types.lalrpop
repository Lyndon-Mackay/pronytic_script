use rust_decimal::Decimal;
use crate::planet_types::PlanetTypeData;

use crate::planet_types::{Action,Branch,Condition,Field,
GoodAbundance, IfCondition ,PlanetTypeToken,Value};



grammar;

extern {
    type Location = usize;
    type Error = String;
    enum PlanetTypeToken {
        "true" => PlanetTypeToken::True,
        "false" => PlanetTypeToken::False,

        "=" => PlanetTypeToken::Equal,

        DecimalNumber => PlanetTypeToken::DecimalNumber(<Decimal>),
        Number => PlanetTypeToken::Number(<Decimal>),
        "name" => PlanetTypeToken::Name(<String>),


        "set_asset" => PlanetTypeToken::SetAsset,
        "set_planet_type" => PlanetTypeToken::SetPlanetType,
        "goods_abundance" => PlanetTypeToken::GoodsAbundance,

        "setup" => PlanetTypeToken::Setup,
        "on_terraform" => PlanetTypeToken::OnTerraform,

        "mean" => PlanetTypeToken::Mean,
        "std_dev" => PlanetTypeToken::StdDev,


        ":" => PlanetTypeToken::Colon,

        "(" => PlanetTypeToken::RightBracket,
        ")" => PlanetTypeToken::LeftBracket,

        "{" => PlanetTypeToken::LeftCurly,
        "}" => PlanetTypeToken::RightCurly,

        "[" => PlanetTypeToken::LeftSquare,
        "]" => PlanetTypeToken::RightSquare,

        "if" => PlanetTypeToken::If,
        "else" => PlanetTypeToken::Else,

        "EQ" => PlanetTypeToken::Eq,
        "IN" => PlanetTypeToken::In,

        "NE" => PlanetTypeToken::Ne,
        "GT" => PlanetTypeToken::Gt,
        "GE" => PlanetTypeToken::Ge,
        "LT" => PlanetTypeToken::Lt,
        "LE" => PlanetTypeToken::Le,

        "&" => PlanetTypeToken::Ampersand,


        "star_type" => PlanetTypeToken::StarType,
        "oxygen_level" => PlanetTypeToken::OxygenLevel,
        "temperature_celsius" => PlanetTypeToken::TemperatureCelsius,
        "temperature_kelvin" => PlanetTypeToken::TemperatureKelvin,
        "water_level" => PlanetTypeToken::WaterLevel,
        "magnetosphere" => PlanetTypeToken::Magnetosphere,
        "atmosphere" => PlanetTypeToken::Atmosphere,
        "goods_base" => PlanetTypeToken::GoodsBase,

        "stored" => PlanetTypeToken::Stored,
        "stored_number" => PlanetTypeToken::StoredNumber,
    }
}


pub PlanetTypeList:Vec<PlanetTypeData> = {
    <list:TypesItem*> => list
}

TypesItem :PlanetTypeData = {
    <name:TypeId> <fields:Field*>   => {

        let mut planet_type_data = PlanetTypeData{
            name,
            ..Default::default()
        };
         for f in fields.into_iter() {
            match f {
                Field::AssetLocation(a) => planet_type_data.asset_location = a,
                Field::Setup(s) => planet_type_data.setup_conditions.push(s),
                Field::GoodsAbundance(g) => planet_type_data.abundances = g,
                Field::Terraform(t) => planet_type_data.terraform_conditions.extend(t),
            }
        }
        planet_type_data
    }
}

TypeId:String = {
    <name:"name"> => name.to_string()
}


Setup:Branch = {
    "setup" "{"  <b:Branch> "}" => {
        b
    }
}

OnTerraform:Vec<Branch> = {
    "on_terraform" "{" <b:Branch*> "}" => {
        b
    }
}


Branch:Branch = {
    <i:If> <elif:ElseIf*> <e:Else?> => {
        let mut if_conditions = vec![i];

        if_conditions.extend(elif);
        Branch {
            if_conditions,
            else_actions:e.unwrap_or_default()
        }
    }
}

If:IfCondition = {
    "if" <c:Condition> <c2:("&" Condition)*>   "{"  <a:Actions*>  "}" => {
        let mut conditions = vec![c];
        let mut actions = Vec::with_capacity(a.len());

        conditions.extend(c2.into_iter().map(|(_,c)|c));
        actions.extend(a);

        IfCondition {
            conditions,
            actions,
        }
    }
}

ElseIf: IfCondition = {
    "else" "if" <c:Condition> <c2:("&" Condition)*> "{" <a:Actions*> "}" => {
        let mut conditions = vec![c];
        conditions.extend(c2.into_iter().map(|(_,c)|c));
        IfCondition {
            conditions,
            actions: a,
        }
    }
}

Else:Vec<Action> ={
    "else" "{" <a:Actions*> "}" => a
}



Condition:Condition = {
    <first:StringValue> <sc:StringCompare> <second:StringValue> => {
        match sc.as_str() {
            "EQ" => Condition::Eq(first,second),
            "NE" => Condition::Ne(first,second),
            _ =>unreachable!(),
        }
    },
    <first:DecimalValue> <dc:DecimalCompare> <second:DecimalValue> => {
        match dc.as_str() {
            "EQ" => Condition::Eq(first,second),
            "NE" => Condition::Ne(first,second),
            "GT" => Condition::Gt(first,second),
            "GE" => Condition::Ge(first,second),
            "LT" => Condition::Lt(first,second),
            "LE" => Condition::Le(first,second),
            _ =>unreachable!(),
        }
    }
}

StringCompare :String = {
    "EQ" => "EQ".to_string(),
    "NE" => "NE".to_string()
}

DecimalCompare:String = {
    "EQ" => "EQ".to_string(),
    "NE" => "NE".to_string(),
    "GT" => "GT".to_string(),
    "GE" => "GE".to_string(),
    "LT" => "LT".to_string(),
    "LE" => "LE".to_string(),
}

StringValue:Value = {
    "star_type" => Value::StarType,
    <s:"name"> => Value::String(s),
    "stored" "[" <s:"name"> "]"=> Value::StringLookup(s),
}

DecimalValue:Value = {
    "oxygen_level" => Value::OxygenLevel,
    "temperature_celsius" => Value::TemperatureCelsius,
    "temperature_kelvin" => Value::TemperatureKelvin,
    "water_level" => Value::WaterLevel,
    "magnetosphere" => Value::Magnetosphere,
    "atmosphere" => Value::Atmosphere,
    "goods_base" "[" <id:"name"> "]" => {
            Value::GoodsAbundance(id)
    },
    <d:DecimalNumber> => {
        Value::Decimal(d)
    },
}
Actions:Action = {
    <a:AssetLocation> => Action::SetAsset(a),
    <p:PlanetType> => Action::SetPlanetType(p),
    <b:Branch> => Action::Branch(b),
    <s:SetStored> => s,
}

Field: Field = {
    <a:AssetLocation> =>Field::AssetLocation(a),
    <g:GoodsAbundance> => Field::GoodsAbundance(g),
    <s:Setup> => Field::Setup(s),
    <t:OnTerraform> => Field::Terraform(t),
}

AssetLocation: String = {
    "set_asset" "=" <id:"name"> => id.to_string()
}
PlanetType:String = {
    "set_planet_type" "=" <id:"name"> => id.to_string()
}

SetStored:Action = {
    "stored" "[" <id:"name"> "]" "=" <value:"name"> =>Action::SetStored(id,value),
    "stored" "[" <id:"name"> "]" "=" "{" <value:"name"+> "}" =>Action::SetStoredRandom(id,value),
}

GoodsAbundance:Vec<GoodAbundance> = {
    "goods_abundance" "=" "[" <g:GoodAbundance*> "]" => g,
}

GoodAbundance:GoodAbundance = {
    //I don't want to actually accept negative numbers,
    //It's just there for the lexar, can be improved to PlanetTypeTokenise seperately
    //Then just or but not up to it ATM
    "{" <id:"name"> "(" "mean" ":" <m:DecimalNumber> "std_dev" ":" <s:DecimalNumber>  ")" "}" => {
        GoodAbundance {
            id,
            mean:m,
            std_dev:s,
        }
    }
}
