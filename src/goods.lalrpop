use crate::goods::{ConsumptionType,Field,GoodData,GoodType,SurvivalConditions,SurvivalField,GoodToken};
use rust_decimal::Decimal;


grammar;

extern {
    type Location = usize;
    type Error = String;

    enum GoodToken {
        "=" => GoodToken::Equal,
        "{" => GoodToken::LeftCurly,
        "}" => GoodToken::RightCurly,
        "string" => GoodToken::String(<String>),
        "number" => GoodToken::DecimalNumber(<Decimal>),
        "icon" => GoodToken::Icon,
        "name" => GoodToken::Name,
        "buy_value" => GoodToken::BuyValue,
        "sell_value" => GoodToken::SellValue,
        "good_type" => GoodToken::GoodType,
        "public" => GoodToken::Public,
        "private" => GoodToken::Private,
        "tender" => GoodToken::Tender,
        "hardcoded_id" => GoodToken::HardcodedId,
        "consumption_type" => GoodToken::ConsumptionType,

        "prosperity_bonus" => GoodToken::ProsperityBonus,
        "prosperity_cost" => GoodToken::ProsperityCost,

        "none" => GoodToken::None,
        "amenity" => GoodToken::Amenity,
        "survival" => GoodToken::Survival,
        "essential" => GoodToken::Essential,

        "magnetosphere" => GoodToken::Magnetosphere,
        "atmosphere" => GoodToken::Atmosphere,
        "temperature" => GoodToken::Temperature,
        "water" => GoodToken::Water,
        "breathability" => GoodToken::Breathability,
        "served_step" => GoodToken::ServedStep,
        "lack_of_service_penalty" => GoodToken::LackServicePenalty,
    }
}

pub Goods:Vec<GoodData> = {
    Good*
}

Good:GoodData = {
    <id:"string"> <fields:Field*> =>{
        let mut hardcoded_id = None;
        let mut icon = String::new();
        let mut name = String::new();
        let mut good_type = GoodType::Public;
        let mut buy_value = Decimal::ZERO;
        let mut sell_value = Decimal::ZERO;
        let mut consumption_type = ConsumptionType::None;
        let mut prosperity_bonus = Decimal::ZERO;
        let mut prosperity_cost = Decimal::ZERO;
        for f in fields {
            match f{
                Field::Icon(i) => icon = i,
                Field::Name(n) => name = n,
                Field::BuyValue(b) => buy_value = b,
                Field::SellValue(s) => sell_value = s,
                Field::GoodType(g) => good_type = g,
                Field::HardcodedId(i) => hardcoded_id = Some(i),
                Field::ConsumptionType(c) => consumption_type = c,
                Field::ProsperityBonus(p) => prosperity_bonus = p,
                Field::ProsperityCost(p) => prosperity_cost = p,
            }
        }
        GoodData {
            id:id.to_string(),
            hardcoded_id,
            icon,
            name,
            good_type,
            consumption_type,
            buy_value,
            sell_value,
            prosperity_bonus,
            prosperity_cost,
        }
    }
}


Field: Field = {
    <i:Icon> => Field::Icon(i),
    <n:Name> => Field::Name(n),
    <b:BuyValue> => Field::BuyValue(b),
    <s:SellValue> => Field::SellValue(s),
    <g:GoodType> => Field::GoodType(g),
    <h:HardcodedId> => Field::HardcodedId(h),
    <c:ConsumptionType> => Field::ConsumptionType(c),
    <p:ProsperityBonus> => Field::ProsperityBonus(p),
    <p:ProsperityCost> => Field::ProsperityCost(p),
}

SurvivalField:SurvivalField = {
    <m:Magnetosphere> => SurvivalField::Magnetosphere(m),
    <a:Atmosphere> => SurvivalField::Atmosphere(a),
    <t:Temperature> => SurvivalField::Temperature(t),
    <w:Water> => SurvivalField::Water(w),
    <b:Breathability> => SurvivalField::Breathability(b),
    <s:ServedStep> => SurvivalField::ServedStep(s),
    <s:LackServicePenalty> => SurvivalField::LackServicePenalty(s),
}

Icon:String ={
    "icon" "=" <s:"string"> => s.to_string(),
}

Name:String ={
    "name" "=" <s:"string"> => s.to_string(),
}

BuyValue:Decimal = {
    "buy_value" "=" <n:"number"> => n,
}

SellValue:Decimal = {
    "sell_value" "=" <n:"number"> => n,
}

ProsperityBonus:Decimal = {
    "prosperity_bonus" "=" <n:"number"> => n,
}

ProsperityCost:Decimal = {
    "prosperity_cost" "=" <n:"number"> => n,
}

GoodType:GoodType = {
    "good_type" "=" "public" => GoodType::Public,
    "good_type" "=" "private" => GoodType::Private,
    "good_type" "=" "tender" => GoodType::Tender,
}

Magnetosphere:Decimal = {
    "magnetosphere" "=" <n:"number"> => n,
}

Atmosphere:Decimal = {
    "atmosphere" "=" <n:"number"> => n,
}

Temperature:Decimal = {
    "temperature" "=" <n:"number"> => n,
}

Water:Decimal = {
    "water" "=" <n:"number"> => n,
}

Breathability:Decimal = {
    "breathability" "=" <n:"number"> => n,
}

ServedStep:Decimal = {
    "served_step" "=" <n:"number"> => n,
}

LackServicePenalty:Decimal = {
    "lack_of_service_penalty" "=" <n:"number"> => n,
}

HardcodedId:u8 = {
    "hardcoded_id" "=" <n:"number"> => n.try_into().unwrap(),
}

ConsumptionType:ConsumptionType = {
    "consumption_type" "=" "essential" => ConsumptionType::Essential,
    "consumption_type" "=" "amenity" => ConsumptionType::Amenity,
    "consumption_type" "=" "none" => ConsumptionType::None,
    "consumption_type" "=" "survival"
     "{" <fields:SurvivalField*> "}" => {
        let mut survival_conditions = SurvivalConditions::default();
        for f in fields{
            match f {
                SurvivalField::Magnetosphere(m) => survival_conditions.magnetosphere = Some(m),
                SurvivalField::Atmosphere(a) => survival_conditions.atmosphere = Some(a),
                SurvivalField::Temperature(t) => survival_conditions.temperature = Some(t),
                SurvivalField::Water(w) => survival_conditions.water = Some(w),
                SurvivalField::Breathability(b) => survival_conditions.breathability = Some(b),
                SurvivalField::ServedStep(s) =>survival_conditions.served_step = s, 
                SurvivalField::LackServicePenalty(s) => survival_conditions.lack_of_service_penalty = s,
            }
        } 
        assert_ne!(survival_conditions,SurvivalConditions::default()); 
        ConsumptionType::Survival(survival_conditions)
    } 
}
